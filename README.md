# Alpha Blending


![result](assets/result.png "Результат блендинга")


## Цель


Закрепить умение оптимизировать однотипные вычисления на CPU с помощью SIMD (см также [Mandelbrot-Set](https://github.com/AndrewGlebovski/Mandelbrot-Set)).


## Введение


Alpha Blending - процесс наложения изображения на фоновое изображение с учетом прозрачности. Цвета каждого пикселя вычисляется по следующей формуле

```
pixel.red   = (foreground_pixel.red   * foreground_pixel.alpha + background_pixel.red   * (255 - foreground_pixel.alpha)) << 8
pixel.green = (foreground_pixel.green * foreground_pixel.alpha + background_pixel.green * (255 - foreground_pixel.alpha)) << 8
pixel.blue  = (foreground_pixel.blue  * foreground_pixel.alpha + background_pixel.blue  * (255 - foreground_pixel.alpha)) << 8
pixel.alpha = 255
```

Т.к. пиксели вычисляются независимо друг от друга, то можно подсчитать сразу несколько с помощью SIMD.


## Ход работы


Сначала будем вычислять цвет каждого "наивным" образом, т.е. по одному пикселю за итерацию внутреннего цикла. Далее воспользуемся SIMD и будем считать по 8 пикселей за итерацию (команды AVX2 используют регистры на 256 бит, при этом каждый пиксель занимает 4 байта, значит в один регистр помещается 8 int чисел, т.е. 8 пикселей). Замерим и сравним FPS в обоих случаях.

Стоит отметить одну особенность в исполнении. Т.к. при умножении целых чисел может возникнуть переполнение, то нужно разбить наш 256-битный регистр пополам на два 128-битных, расширить размер каждого операнда с одного байта до двух (команда _mm256_cvtepu8_epi16) и производить арифметические операции с ними. После уменьшить каждый операнд с двух байт до одного, взяв старший байт, и "склеить" получившиеся 128-битные регистры.


## Анализ работы компилятора


С помощью сайта godbolt.org проанализируем существенные различия при компиляции "наивной" и SIMD реализаций.

[Полный результат наивной реализации](https://godbolt.org/z/faMKhW3T6)

[Полный результат SIMD реализации](https://godbolt.org/z/nchY8YYrT)

**Красным цветом обведены обращения к памяти. Желтым - арифметические операции**

В наивной реализации компилятор обращается к памяти за каждым байтом, что сильно замедляет расчет цвета пикселя. Кроме того наивный алгоритм производит ровно 3 сложения и 6 умножений над каждым пикселем.

![naive-cmp](assets/naive_cmp.png "Сравнение исходника и ассемблерного результата")

В SIMD реализиции компилятор читает/записывает по 32 байта за раз, что сильно сокращает время работы с памятью. Также SIMD производит все арифметический команды над 8 пикселями сразу.

![simd-cmp](assets/simd_cmp.png "Сравнение исходника и ассемблерного результата")


## Результат


**Условия**
- Все измерения производились с опцией -O2 компилятора gcc, а также набором инструкций AVX2
- Для того, чтобы уменьшить влияние факторов не связанных с вычислением множества, я считаю пиксели 10000 раз после чего умножаю полученный FPS на 10000
- Компьютер был подключен к сети, замеры проводились при одной температуре (чтобы избежать искажения FPS из-за троттлинга CPU).

Средний FPS:

| SIMD | FPS   |
| ---- | ----- |
| Off  | 1242  |
| On   | 4804  |

Коэффициент ускорения:

|                | Коэффициент ускорения |
| -------------- | --------------------- |
| Теоретический  | 8                     |
| Практический   | 3.8                   |


## Вывод


Использование SIMD позволяет свернуть несколько итераций цикла в одну, если каждая итерация выполняется независимо от других, что позволяет существенно ускорить выполнение цикла. Для этого используются специальные ассемблерные вставки, поддерживаемые компилятором (интринсики).
